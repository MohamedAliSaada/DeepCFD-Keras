# -*- coding: utf-8 -*-
"""DeepCFD

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12FvaiBdMzLRCR4AhlyrzTtls6ePoegms

# Data phase
"""

from zipfile import ZipFile
import requests
import io
import matplotlib.pyplot as plt
import numpy as np
import pickle

# load the data via ural
data =  requests.get("https://zenodo.org/record/3666056/files/DeepCFD.zip?download=1")

# make un zip to that file content
with ZipFile(io.BytesIO(data.content)) as f:
  f.extractall("DeepCFD")

#open and load data of x and y
with open("/content/DeepCFD/dataX.pkl" , "rb") as ff:
  dataX = pickle.load(ff)
with open("/content/DeepCFD/dataY.pkl" , "rb") as ff:
  dataY = pickle.load(ff)

# show sample of data some data
fig, axs = plt.subplots(2,3 , figsize=(12,12))
sample = 10
for i, ax in enumerate(axs.flat):
  if i <=2:
    ax.imshow(dataX[sample][i] , cmap='jet')
    if i==0:
      ax.set_title(f"the SDF channel-{i}")
    elif i==1:
      ax.set_title(f"the multi-label flow region channel-{i}")
    else:
      ax.set_title(f"SDF from the top/bottom surfaces channel-{i}")
  if i >=3:
    ax.imshow(dataY[sample][abs(i-3)] , cmap='jet')
    if i==3:
      ax.set_title(f"Ux horizontal velocity component channel-{abs(i-3)}")
    elif i==4:
      ax.set_title(f"Uy vertical velocity component channel-{abs(i-3)}")
    else:
      ax.set_title(f"the pressure field channel-{abs(i-3)}")
  if i==5:
    break
plt.tight_layout()
plt.show()

# get the rms values of output data to use as noralization to channels (channels_weights)
def rms(arr):
  return np.sqrt(np.mean(np.square(arr)))

rms_values =[rms(dataY[:,i,:,:]) for i in range(3)] # RMS for Ux , Uy and Pressure

inv_rms = [1.0 / x for x in rms_values]
sum_inv_rms = sum(inv_rms)
normalized_weights = [x / sum_inv_rms for x in inv_rms]

#modify my input shapes to use in model
X = np.transpose(dataX,(0,2,3,1))
Y = np.transpose(dataY,(0,2,3,1))


del dataX, dataY

import tensorflow as tf
from PIL import Image
tf.random.set_seed(42)

X_resized = tf.image.resize(X, size=(176, 80))
Y_resized = tf.image.resize(Y, size=(176, 80))

del Y,X

"""# Model Phase"""

X_resized.shape

import tensorflow as tf
from tensorflow.keras import layers, Input, Model

# ========== Encoder Block ==========
def encoder_block(x, filters, kernel_size=3):
    x = layers.Conv2D(filters, kernel_size, padding='same')(x)
    #x = layers.BatchNormalization()(x)
    x = layers.ReLU()(x)

    x = layers.Conv2D(filters, kernel_size, padding='same')(x)
    #x = layers.BatchNormalization()(x)
    x = layers.ReLU()(x)

    skip = x
    x = layers.MaxPooling2D(pool_size=(2, 2), padding='same')(x)
    return x, skip

# ========== Decoder Block ==========
def decoder_block(x, skip, filters, kernel_size=3):
    x = layers.UpSampling2D(size=(2, 2), interpolation='nearest')(x)
    x = layers.Concatenate()([x, skip])

    x = layers.Conv2D(filters, kernel_size, padding='same')(x)
    #x = layers.BatchNormalization()(x)
    x = layers.ReLU()(x)

    x = layers.Conv2D(filters, kernel_size, padding='same')(x)
    #x = layers.BatchNormalization()(x)
    x = layers.ReLU()(x)

    return x

# ========== Full U-Net With One Decoder and 3-channel Output ==========
def Unet_single_decoder(input_shape=(176, 80, 3)):
    inputs = Input(shape=input_shape)

    # ----- Encoder -----
    x, skip1 = encoder_block(inputs, 8)
    x, skip2 = encoder_block(x, 16)
    x, skip3 = encoder_block(x, 32)

    # ----- Bottleneck -----
    x = layers.Conv2D(32, 3, padding='same')(x)
    #x = layers.BatchNormalization()(x)
    x = layers.ReLU()(x)

    # ----- Decoder -----
    x = decoder_block(x, skip3, 32)
    x = decoder_block(x, skip2, 16)
    x = decoder_block(x, skip1, 8)

    # ----- Final Output -----
    outputs = layers.Conv2D(1, 1, activation='linear', name='output')(x)

    return Model(inputs, outputs, name='DeepCFD_U-Net_single_decoder')

#make the model
model=Unet_single_decoder(input_shape=(176, 80, 3))

model.summary()

#compile the model
from tensorflow.keras.optimizers import Adam
model.compile(optimizer=Adam(learning_rate=1e-6),loss='mse', metrics=['mse'])

#make callbacks to use while my model train
from tensorflow.keras.callbacks import ReduceLROnPlateau, EarlyStopping, ModelCheckpoint

early_stopping = EarlyStopping(
    monitor='val_loss',
    patience=4,
    mode='min',
    restore_best_weights=True,
    verbose=1
)

check_point = ModelCheckpoint(
    filepath='deepcfdV1.keras',
    save_best_only=True,
    monitor='val_loss',
    mode='min',
    verbose=1
)

reduce_lr = ReduceLROnPlateau(
    monitor="val_loss",
    factor=0.2,
    patience=3,
    verbose=1,
    mode="auto",
    min_lr=1e-9
)

callbacks = [early_stopping, check_point, reduce_lr]

# run the model
history=model.fit(
    X_resized, Y_resized[:,:,:,0],
    validation_split=.10,
    epochs=200,
    callbacks=callbacks

)

"""# plots from model phase"""

import pandas as pd

df =  pd.DataFrame(history.history)
df.head()

epochs=20

plt.subplot(1,3,1)
plt.plot(range(epochs), df['val_loss'])
plt.xlabel("epochs")
plt.ylabel("Ux")

plt.subplot(1,3,2)
plt.plot(range(epochs), df['val_mse'])
plt.xlabel("epochs")
plt.ylabel("Ux")

plt.subplot(1,3,3)
plt.plot(range(epochs), df['mse'])
plt.xlabel("epochs")
plt.ylabel("Ux")



plt.suptitle("Validation Error (MSE)", fontsize=16)
plt.tight_layout()
plt.show()

model.evaluate(X_resized,Y_resized[:,:,:,0])

"""# Test model phase"""

from tensorflow.keras.models import load_model

m = load_model('deepcfdV1.keras')

input_sample = np.expand_dims(X_resized[500,:,:,:] , axis=0)

output= m.predict(input_sample)

plt.imshow(output[0][:, :,0] , cmap="jet" , vmin=np.min(Y_resized[0][:, :,0]), vmax=np.max(Y_resized[0][:, :,0]))

plt.imshow(Y_resized[500][:, :,0] , cmap="jet", vmin=np.min(Y_resized[0][:, :,0]), vmax=np.max(Y_resized[0][:, :,0]))



"""# Comparison between ground-truth CFD (simpleFOAM) and DeepCFD prediction"""

import matplotlib.pyplot as plt
import numpy as np
from mpl_toolkits.axes_grid1 import make_axes_locatable

# Choose index
i = 900

input_sample = np.expand_dims(X_resized[i,:,:,:] , axis=0)
output= m.predict(input_sample)

# Data
prediction = output[0][:, :, 0]
ground_truth = Y_resized[i][:, :, 0]
error_img = np.abs(prediction - ground_truth)

# Shared color scale for prediction and ground truth
vmin = np.min(ground_truth)
vmax = np.max(ground_truth)

# Plot
fig, axes = plt.subplots(1, 3, figsize=(16, 5))

titles = ["DeepCFD Prediction (Ux)", "Ground Truth (Ux)", "Absolute Error (|Pred - GT|)"]
images = [prediction, ground_truth, error_img]
cmaps = ["jet", "jet", "jet"]
vmins = [vmin, vmin, None]
vmaxs = [vmax, vmax, None]

for ax, title, img, cmap, vmin_, vmax_ in zip(axes, titles, images, cmaps, vmins, vmaxs):
    im = ax.imshow(img, cmap=cmap, vmin=vmin_, vmax=vmax_)
    ax.set_title(title)
    ax.axis("off")

    # Attach a small colorbar to each image
    divider = make_axes_locatable(ax)
    cax = divider.append_axes("right", size="5%", pad=0.05)
    plt.colorbar(im, cax=cax)

plt.tight_layout()
plt.show()

