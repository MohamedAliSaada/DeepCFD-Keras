# -*- coding: utf-8 -*-
"""SDF

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12FvaiBdMzLRCR4AhlyrzTtls6ePoegms
"""

import numpy as np
import matplotlib.pyplot as plt

# 1. Create an empty black image of size 100x100
width, height = 100, 100
img = np.zeros((height, width), dtype=np.float32)

# the SDF is “How far is this point from the edge of a shape — and am I inside or outside?”
# it give you +/-/0 that is mean outside/on edge/inside of the shape
# the SDF is a concept and a technique — not one universal formula. that is :
#   @-any function f(x,y,z) that:
#      1- give + if outside.
#      2- give - if outside.
#      3- give 0 if on edge of shape.
#######################################################
#This means each shape has its own custom SDF formula.#
#######################################################

# ===  Define the SDF for a circle ===
def sdf_circle(x, y, cx, cy, r):
    dx = x - cx
    dy = y - cy
    return np.sqrt(dx**2 + dy**2) - r

#assume  ===  Circle parameters ===
center_x = 50
center_y = 50
radius = 30

int(sdf_circle(1,1,center_x,center_y,radius))   #give + mean outside
int(sdf_circle(46,40,center_x,center_y,radius)) #give - mean inside
int(sdf_circle(80,50,center_x,center_y,radius)) #give 0 mean on the edge of circle

# ===  Fill the image based on SDF values ===

for y in range(height):
  for x in range(width): #this mean x1,x2,.... with y1 then x1,x2,... with y2 and so on
     value=sdf_circle(x,y,center_x,center_y,radius)
     if abs(value) < .1:
      img[y,x] = 127   #gray mean on egde
     elif value <0:
      img[y,x] = 255 #white mean inside
     else :
      img[y,x] = 0   #black mean outside

plt.imshow(img , cmap='gray')
plt.axis("off")
plt.show()

# ===  Fill the image based on SDF values but simulate a shadow effect
# or soft edge glow using SDF — by assigning pixel values based on the distance from the shape's boundary,
# and applying a colormap (cmap) to visualize it. ===

for y in range(height):
  for x in range(width): #this mean x1,x2,.... with y1 then x1,x2,... with y2 and so on
     value=sdf_circle(x,y,center_x,center_y,radius)
     img[y,x] = value

img= np.clip(img,-5,5) #keep from -5 to 5 only and make below or above as -5 & 5
img = (img - (-5)) / ((5) - (-5)) #make normalization to img so be from 0-1

plt.imshow(img , cmap='plasma')
plt.axis("off")
plt.show()


###########
##note 1
###########

#When you move a shape, the GPU re-runs the SDF formula for every pixel using the new position.
#The shadow or glow updates instantly, because the GPU calculates it live every frame — not using stored pixels, but pure math.

###########
##note 2
###########

#Yes — SDF handles shape + distance,
#but to show light, glow, or shadow, you need extra formulas for lighting.

